<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ú–µ—Ç–æ–¥ –î–ü - –î–µ—Ä–µ–≤–æ –≤–Ω–∏–∑ –≥–æ–ª–æ–≤–æ–π</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 32px;
            margin-bottom: 10px;
        }
        
        .container {
            display: flex;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .graph-area {
            flex: 2;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        
        .sidebar {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .panel {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        
        .panel h3 {
            margin-bottom: 15px;
            color: #333;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 600px;
            border: 2px solid #eee;
            border-radius: 10px;
        }
        
        button {
            padding: 12px 24px;
            margin: 5px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        button.primary {
            background: #667eea;
            color: white;
        }
        
        button.primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }
        
        button.secondary {
            background: #27ae60;
            color: white;
        }
        
        button.secondary:hover {
            background: #229954;
        }
        
        .dp-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        
        .dp-table th, .dp-table td {
            padding: 10px;
            border: 1px solid #ddd;
            text-align: center;
        }
        
        .dp-table th {
            background: #667eea;
            color: white;
        }
        
        .dp-table tr.current {
            background: #fff3cd;
            font-weight: bold;
        }
        
        .dp-table tr.completed {
            background: #d4edda;
        }
        
        .formula {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            border-left: 4px solid #667eea;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }
        
        .info-box {
            background: #e8f4f8;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üå≥ –ú–µ—Ç–æ–¥ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è</h1>
        <p>–ü–æ–¥—Å—á—ë—Ç –ø—É—Ç–µ–π –≤ –≥—Ä–∞—Ñ–µ: "–î–µ—Ä–µ–≤–æ –≤–Ω–∏–∑ –≥–æ–ª–æ–≤–æ–π"</p>
    </div>
    
    <div class="container">
        <div class="graph-area">
            <div style="margin-bottom: 15px; padding: 15px; background: #e8f4f8; border-radius: 8px;">
                <h3 style="margin: 0 0 10px 0; color: #333;">üìÅ –®–∞–≥ 1: –ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≥—Ä–∞—Ñ–∞</h3>
                <input type="file" id="imageInput" accept="image/*" onchange="loadImage(event)" style="padding: 10px; width: 100%; border: 2px solid #667eea; border-radius: 6px;">
                <div style="margin-top: 10px; display: flex; gap: 10px;">
                    <button class="primary" onclick="setMode('node')" id="nodeModeBtn">‚ûï –î–æ–±–∞–≤–∏—Ç—å –≤–µ—Ä—à–∏–Ω—É</button>
                    <button class="primary" onclick="setMode('edge')" id="edgeModeBtn">‚ÜîÔ∏è –î–æ–±–∞–≤–∏—Ç—å —Ä–µ–±—Ä–æ</button>
                    <button class="secondary" onclick="clearGraph()">üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å –≥—Ä–∞—Ñ</button>
                </div>
            </div>
            <canvas id="canvas"></canvas>
            <div class="controls">
                <button class="secondary" onclick="buildDPGraph()">üî® –ü–æ—Å—Ç—Ä–æ–∏—Ç—å –î–ü-–≥—Ä–∞—Ñ</button>
                <button class="secondary" onclick="startAnimation()">‚ñ∂Ô∏è –ó–∞–ø—É—Å—Ç–∏—Ç—å –∞–Ω–∏–º–∞—Ü–∏—é</button>
                <button class="primary" onclick="stepForward()">‚û°Ô∏è –°–ª–µ–¥—É—é—â–∏–π —à–∞–≥</button>
                <button class="primary" onclick="reset()">üîÑ –°–±—Ä–æ—Å</button>
            </div>
        </div>
        
        <div class="sidebar">
            <div class="panel">
                <h3>üìä –¢–∞–±–ª–∏—Ü–∞ –¥–∏–Ω–∞–º–∏–∫–∏</h3>
                <table class="dp-table" id="dpTable">
                    <thead>
                        <tr>
                            <th>–í–µ—Ä—à–∏–Ω–∞</th>
                            <th>–ö–æ–ª-–≤–æ –ø—É—Ç–µ–π</th>
                        </tr>
                    </thead>
                    <tbody id="tableBody"></tbody>
                </table>
            </div>
            
            <div class="panel">
                <h3>üßÆ –¢–µ–∫—É—â–µ–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ</h3>
                <div id="formulaBox" class="formula">
                    –ù–∞–∂–º–∏—Ç–µ "–ó–∞–ø—É—Å—Ç–∏—Ç—å –∞–Ω–∏–º–∞—Ü–∏—é"
                </div>
            </div>
            
            <div class="panel">
                <h3>‚ÑπÔ∏è –ê–ª–≥–æ—Ä–∏—Ç–º</h3>
                <div class="info-box">
                    <strong>–ú–µ—Ç–æ–¥ –î–ü –¥–ª—è DAG:</strong><br><br>
                    1. –ù–∞—á–∞–ª—å–Ω–∞—è –≤–µ—Ä—à–∏–Ω–∞ = 1 –ø—É—Ç—å<br>
                    2. –î–ª—è –∫–∞–∂–¥–æ–π —Å–ª–µ–¥—É—é—â–µ–π –≤–µ—Ä—à–∏–Ω—ã:<br>
                    &nbsp;&nbsp;&nbsp;–ü—É—Ç–∏ = –°–£–ú–ú–ê –ø—É—Ç–µ–π –∏–∑ –≤—Å–µ—Ö –≤—Ö–æ–¥—è—â–∏—Ö —Ä—ë–±–µ—Ä<br>
                    3. –ö–æ–Ω–µ—á–Ω–∞—è –≤–µ—Ä—à–∏–Ω–∞ = –∏—Ç–æ–≥
                </div>
            </div>
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let sourceImage = null;
        let nodes = [];
        let edges = [];
        let mode = 'node';
        let selectedNode = null;
        let nextLetter = 65; // A
        let dpMode = false; // –†–µ–∂–∏–º –î–ü-–≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
        
        // –ì—Ä–∞—Ñ –¥–ª—è –î–ü (–±—É–¥–µ—Ç —Å–æ–∑–¥–∞–Ω –∏–∑ –æ—Ç–º–µ—á–µ–Ω–Ω—ã—Ö –≤–µ—Ä—à–∏–Ω)
        let graph = {
            nodes: [],
            edges: []
        };
        
        let dpValues = {};  // –ó–Ω–∞—á–µ–Ω–∏—è –î–ü –¥–ª—è –∫–∞–∂–¥–æ–π –≤–µ—Ä—à–∏–Ω—ã
        let currentStep = 0;
        let sortedNodes = [];
        let animationInterval = null;
        let animationQueue = []; // –û—á–µ—Ä–µ–¥—å —à–∞–≥–æ–≤: {type: 'edge'/'node', data: ...}
        let shownEdges = new Set(); // –ü–æ–∫–∞–∑–∞–Ω–Ω—ã–µ —Ä—ë–±—Ä–∞
        let shownNodes = new Set(); // –ü–æ–∫–∞–∑–∞–Ω–Ω—ã–µ –≤–µ—Ä—à–∏–Ω—ã
        
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            draw();
        }
        
        window.addEventListener('resize', resizeCanvas);
        setTimeout(resizeCanvas, 100);
        
        function topologicalSort() {
            // –ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π –∞–ª–≥–æ—Ä–∏—Ç–º –ö–∞–Ω–∞ –¥–ª—è —Ç–æ–ø–æ–ª–æ–≥–∏—á–µ—Å–∫–æ–π —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏
            const inDegree = {};
            const result = [];
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
            graph.nodes.forEach(node => {
                inDegree[node.id] = 0;
            });
            
            // –ü–æ–¥—Å—á—ë—Ç –≤—Ö–æ–¥—è—â–∏—Ö —Ä—ë–±–µ—Ä
            graph.edges.forEach(edge => {
                inDegree[edge.to]++;
            });
            
            // –û—á–µ—Ä–µ–¥—å –≤–µ—Ä—à–∏–Ω –±–µ–∑ –≤—Ö–æ–¥—è—â–∏—Ö —Ä—ë–±–µ—Ä (–æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ)
            let queue = graph.nodes.filter(n => inDegree[n.id] === 0).sort((a, b) => a.id.localeCompare(b.id));
            
            while (queue.length > 0) {
                const current = queue.shift();
                result.push(current);
                
                // –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ –∏—Å—Ö–æ–¥—è—â–∏–µ —Ä—ë–±—Ä–∞ –∏ —É–º–µ–Ω—å—à–∞–µ–º inDegree
                const outgoing = graph.edges.filter(e => e.from === current.id);
                
                outgoing.forEach(edge => {
                    inDegree[edge.to]--;
                    if (inDegree[edge.to] === 0) {
                        const nextNode = graph.nodes.find(n => n.id === edge.to);
                        if (nextNode) {
                            // –í—Å—Ç–∞–≤–ª—è–µ–º –≤ –æ—á–µ—Ä–µ–¥—å –≤ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
                            const insertIndex = queue.findIndex(n => n.id > nextNode.id);
                            if (insertIndex === -1) {
                                queue.push(nextNode);
                            } else {
                                queue.splice(insertIndex, 0, nextNode);
                            }
                        }
                    }
                });
            }
            
            return result;
        }
        
        function buildAnimationQueue() {
            animationQueue = [];
            
            // –î–ª—è –∫–∞–∂–¥–æ–π –≤–µ—Ä—à–∏–Ω—ã (–∫—Ä–æ–º–µ –ø–µ—Ä–≤–æ–π) –¥–æ–±–∞–≤–ª—è–µ–º:
            // 1. –†—ë–±—Ä–∞ –∫ –Ω–µ–π
            // 2. –°–∞–º—É –≤–µ—Ä—à–∏–Ω—É
            for (let i = 1; i < sortedNodes.length; i++) {
                const node = sortedNodes[i];
                const incomingEdges = graph.edges.filter(e => e.to === node.id);
                
                // –î–æ–±–∞–≤–ª—è–µ–º —Ä—ë–±—Ä–∞ –∫ —ç—Ç–æ–π –≤–µ—Ä—à–∏–Ω–µ
                incomingEdges.forEach(edge => {
                    animationQueue.push({
                        type: 'edge',
                        edgeKey: `${edge.from}->${edge.to}`
                    });
                });
                
                // –î–æ–±–∞–≤–ª—è–µ–º —Å–∞–º—É –≤–µ—Ä—à–∏–Ω—É
                animationQueue.push({
                    type: 'node',
                    nodeId: node.id
                });
            }
        }
        
        function reset() {
            currentStep = 0;
            dpValues = {};
            sortedNodes = topologicalSort();
            dpValues[sortedNodes[0].id] = 1; // A = 1
            
            // –°–æ–∑–¥–∞—ë–º –æ—á–µ—Ä–µ–¥—å –∞–Ω–∏–º–∞—Ü–∏–∏
            buildAnimationQueue();
            
            console.log('–û—á–µ—Ä–µ–¥—å –∞–Ω–∏–º–∞—Ü–∏–∏ (' + animationQueue.length + ' —à–∞–≥–æ–≤):');
            animationQueue.forEach((step, i) => {
                if (step.type === 'edge') {
                    console.log(`  ${i}: edge ${step.edgeKey}`);
                } else {
                    console.log(`  ${i}: node ${step.nodeId}`);
                }
            });
            
            shownEdges = new Set();
            shownNodes = new Set();
            shownNodes.add(sortedNodes[0].id); // –ü–µ—Ä–≤–∞—è –≤–µ—Ä—à–∏–Ω–∞ —Å—Ä–∞–∑—É –≤–∏–¥–Ω–∞
            
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
            
            updateTable();
            updateFormula();
            draw();
        }
        
        function stepForward() {
            console.log(`stepForward() –≤—ã–∑–≤–∞–Ω: currentStep=${currentStep}, animationQueue.length=${animationQueue.length}`);
            
            if (currentStep >= animationQueue.length) {
                console.log('  –ê–Ω–∏–º–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!');
                return;
            }
            
            const step = animationQueue[currentStep];
            console.log(`  –®–∞–≥ ${currentStep}: type=${step.type}, ${step.type === 'edge' ? 'edgeKey=' + step.edgeKey : 'nodeId=' + step.nodeId}`);
            
            currentStep++;
            
            if (step.type === 'edge') {
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–µ–±—Ä–æ
                shownEdges.add(step.edgeKey);
                console.log(`    –î–æ–±–∞–≤–ª–µ–Ω–æ —Ä–µ–±—Ä–æ ${step.edgeKey}, –≤—Å–µ–≥–æ –ø–æ–∫–∞–∑–∞–Ω–æ —Ä—ë–±–µ—Ä: ${shownEdges.size}`);
            } else if (step.type === 'node') {
                // –í—ã—á–∏—Å–ª—è–µ–º –∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤–µ—Ä—à–∏–Ω—É
                calculateDP(step.nodeId);
                shownNodes.add(step.nodeId);
                console.log(`    –î–æ–±–∞–≤–ª–µ–Ω–∞ –≤–µ—Ä—à–∏–Ω–∞ ${step.nodeId}, dpValue=${dpValues[step.nodeId]}, –≤—Å–µ–≥–æ –ø–æ–∫–∞–∑–∞–Ω–æ –≤–µ—Ä—à–∏–Ω: ${shownNodes.size}`);
            }
            
            updateTable();
            updateFormula();
            draw();
        }
        
        function calculateDP(nodeId) {
            let sum = 0;
            const incoming = graph.edges.filter(e => e.to === nodeId);
            
            incoming.forEach(edge => {
                if (dpValues[edge.from] !== undefined) {
                    sum += dpValues[edge.from];
                }
            });
            
            dpValues[nodeId] = sum || 0;
        }
        
        function updateTable() {
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = '';
            
            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–µ–∫—É—â—É—é –≤–µ—Ä—à–∏–Ω—É (–ø–æ—Å–ª–µ–¥–Ω—è—è –¥–æ–±–∞–≤–ª–µ–Ω–Ω–∞—è)
            let currentNodeId = null;
            if (currentStep > 0 && animationQueue[currentStep - 1]?.type === 'node') {
                currentNodeId = animationQueue[currentStep - 1].nodeId;
            }
            
            sortedNodes.forEach((node) => {
                const tr = document.createElement('tr');
                const value = dpValues[node.id];
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á–µ—Ä–µ–∑ shownNodes
                if (node.id === currentNodeId) {
                    tr.className = 'current';
                } else if (shownNodes.has(node.id) && node.id !== currentNodeId) {
                    tr.className = 'completed';
                }
                
                tr.innerHTML = `
                    <td><strong>${node.id}</strong></td>
                    <td>${value !== undefined ? value : '-'}</td>
                `;
                
                tbody.appendChild(tr);
            });
        }
        
        function updateFormula() {
            const formulaBox = document.getElementById('formulaBox');
            
            if (currentStep === 0) {
                formulaBox.innerHTML = `<strong>${sortedNodes[0].id} = 1</strong> (–Ω–∞—á–∞–ª—å–Ω–∞—è –≤–µ—Ä—à–∏–Ω–∞)`;
                return;
            }
            
            // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π —à–∞–≥ –∏–∑ –æ—á–µ—Ä–µ–¥–∏ –∞–Ω–∏–º–∞—Ü–∏–∏
            const stepIndex = currentStep - 1;
            if (stepIndex < 0 || stepIndex >= animationQueue.length) {
                return;
            }
            
            const step = animationQueue[stepIndex];
            
            // –§–æ—Ä–º—É–ª—É –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –¥–ª—è –≤–µ—Ä—à–∏–Ω, –Ω–µ –¥–ª—è —Ä—ë–±–µ—Ä
            if (step.type !== 'node') {
                return;
            }
            
            const nodeId = step.nodeId;
            const incoming = graph.edges.filter(e => e.to === nodeId);
            
            if (incoming.length === 0) {
                formulaBox.innerHTML = `<strong>${nodeId} = 0</strong> (–Ω–µ—Ç –≤—Ö–æ–¥—è—â–∏—Ö —Ä—ë–±–µ—Ä)`;
                return;
            }
            
            const parts = incoming.map(e => {
                const val = dpValues[e.from] || 0;
                return `${e.from}(${val})`;
            });
            
            const sum = dpValues[nodeId] || 0;
            formulaBox.innerHTML = `
                <strong>${nodeId} = ${parts.join(' + ')}</strong><br>
                <strong>${nodeId} = ${sum}</strong>
            `;
        }
        
        function draw() {
            console.log(`draw() –≤—ã–∑–≤–∞–Ω: dpMode=${dpMode}, canvas=${canvas.width}x${canvas.height}`);
            
            try {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                console.log(`draw(): dpMode=${dpMode}, canvas size=${canvas.width}x${canvas.height}, shownEdges=${shownEdges.size}, shownNodes=${shownNodes.size}`);
                
                if (!dpMode) {
                    // –†–µ–∂–∏–º —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è: —Ä–∏—Å—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å –æ—Ç–º–µ—Ç–∫–∞–º–∏
                    if (sourceImage) {
                        ctx.drawImage(sourceImage, 0, 0);
                    }
                    
                    // –†–∏—Å—É–µ–º —Ä—ë–±—Ä–∞ (–±–µ–∑ –≤–µ—Å–æ–≤ –≤ —Ä–µ–∂–∏–º–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è)
                    edges.forEach(edge => {
                        drawArrow(edge.from.x, edge.from.y, edge.to.x, edge.to.y, '#667eea', 3);
                    });
                    
                    // –†–∏—Å—É–µ–º –≤–µ—Ä—à–∏–Ω—ã
                    nodes.forEach(node => {
                        const isSelected = (selectedNode === node);
                        drawNode(node.x, node.y, node.label, null, isSelected ? '#ff6b6b' : '#667eea', isSelected, true);
                    });
                } else {
                    // –†–µ–∂–∏–º –î–ü-–≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
                    console.log(`  –í —Ä–µ–∂–∏–º–µ –î–ü: graph.edges=${graph.edges.length}, graph.nodes=${graph.nodes.length}`);
                    
                    // –†–∏—Å—É–µ–º –í–°–ï —Ä—ë–±—Ä–∞ (–∞–∫—Ç–∏–≤–Ω—ã–µ –∏ –Ω–µ–∞–∫—Ç–∏–≤–Ω—ã–µ)
                    let drawnEdges = 0;
                    graph.edges.forEach(edge => {
                        const edgeKey = `${edge.from}->${edge.to}`;
                        const isActive = shownEdges.has(edgeKey);
                        
                        drawnEdges++;
                        const from = graph.nodes.find(n => n.id === edge.from);
                        const to = graph.nodes.find(n => n.id === edge.to);
                        if (from && to) {
                            // –ù–µ–∞–∫—Ç–∏–≤–Ω—ã–µ —Ä—ë–±—Ä–∞ - –æ—á–µ–Ω—å –±–ª–µ–∫–ª—ã–µ, –∞–∫—Ç–∏–≤–Ω—ã–µ - –±–æ–ª–µ–µ —è—Ä–∫–∏–µ
                            const edgeColor = isActive ? '#999' : '#e0e0e0';
                            const edgeWidth = isActive ? 2 : 1;
                            drawArrow(from.x, from.y, to.x, to.y, edgeColor, edgeWidth);
                            
                            // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º –≤–µ—Å —Ä–µ–±—Ä–∞ –¢–û–õ–¨–ö–û –¥–ª—è –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ä—ë–±–µ—Ä
                            if (isActive) {
                                const weight = dpValues[from.id];
                                if (weight !== undefined) {
                                    const midX = (from.x + to.x) / 2;
                                    const midY = (from.y + to.y) / 2;
                                    
                                    // –†–∏—Å—É–µ–º –±–µ–ª—ã–π –∫—Ä—É–≥ –ø–æ–¥ —Ç–µ–∫—Å—Ç–æ–º
                                    ctx.beginPath();
                                    ctx.arc(midX, midY, 15, 0, 2 * Math.PI);
                                    ctx.fillStyle = 'white';
                                    ctx.fill();
                                    ctx.strokeStyle = '#667eea';
                                    ctx.lineWidth = 2;
                                    ctx.stroke();
                                    
                                    // –†–∏—Å—É–µ–º –≤–µ—Å
                                    ctx.fillStyle = '#667eea';
                                    ctx.font = 'bold 14px Arial';
                                    ctx.textAlign = 'center';
                                    ctx.textBaseline = 'middle';
                                    ctx.fillText(weight, midX, midY);
                                }
                            }
                        }
                    });
                    
                    console.log(`  –ù–∞—Ä–∏—Å–æ–≤–∞–Ω–æ —Ä—ë–±–µ—Ä: ${drawnEdges}`);
                    
                    // –†–∏—Å—É–µ–º –í–°–ï –≤–µ—Ä—à–∏–Ω—ã
                    let drawnNodes = 0;
                    console.log(`  –ù–∞—á–∏–Ω–∞–µ–º —Ä–∏—Å–æ–≤–∞—Ç—å –≤–µ—Ä—à–∏–Ω—ã, shownNodes —Å–æ–¥–µ—Ä–∂–∏—Ç: ${Array.from(shownNodes).join(', ')}`);
                    
                    graph.nodes.forEach((node, index) => {
                        drawnNodes++;
                        
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∞–∫—Ç–∏–≤–Ω–∞ –ª–∏ –≤–µ—Ä—à–∏–Ω–∞ (–ø–æ–∫–∞–∑–∞–Ω–∞ –≤ –∞–Ω–∏–º–∞—Ü–∏–∏)
                        const isActive = shownNodes.has(node.id);
                        const value = isActive ? dpValues[node.id] : undefined;
                        const isCurrent = (currentStep > 0 && animationQueue[currentStep - 1]?.type === 'node' && animationQueue[currentStep - 1]?.nodeId === node.id);
                        const isCompleted = isActive && dpValues[node.id] !== undefined && !isCurrent;
                        
                        if (drawnNodes <= 5) {
                            console.log(`    –í–µ—Ä—à–∏–Ω–∞ ${node.id}: x=${node.x}, y=${node.y}, isActive=${isActive}, value=${value}, isCurrent=${isCurrent}`);
                        }
                        
                        // –¶–≤–µ—Ç –≤–µ—Ä—à–∏–Ω—ã
                        let color = '#f0f0f0'; // –ù–µ–∞–∫—Ç–∏–≤–Ω–∞—è (—Å–µ—Ä–∞—è)
                        if (isActive) {
                            if (isCurrent) color = '#fff3cd'; // –¢–µ–∫—É—â–∞—è (–∂–µ–ª—Ç–∞—è)
                            else if (isCompleted) color = '#d4edda'; // –ó–∞–≤–µ—Ä—à–µ–Ω–Ω–∞—è (–∑–µ–ª–µ–Ω–∞—è)
                        }
                        
                        console.log(`    –í—ã–∑—ã–≤–∞–µ–º drawNode –¥–ª—è ${node.id} —Å —Ü–≤–µ—Ç–æ–º ${color}, isActive=${isActive}`);
                        drawNode(node.x, node.y, node.id, value, color, isCurrent, isActive);
                    });
                    
                    console.log(`  –ù–∞—Ä–∏—Å–æ–≤–∞–Ω–æ –≤–µ—Ä—à–∏–Ω: ${drawnNodes}`);
                }
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –≤ draw():', error);
            }
        }
        
        function drawNode(x, y, label, value, bgColor, isCurrent, isActive) {
            try {
                console.log(`  drawNode –≤—ã–∑–≤–∞–Ω: label=${label}, x=${x}, y=${y}, value=${value}, bgColor=${bgColor}, isActive=${isActive}`);
                
                // –ö—Ä—É–≥ –≤–µ—Ä—à–∏–Ω—ã
                ctx.beginPath();
                ctx.arc(x, y, 30, 0, 2 * Math.PI);
                ctx.fillStyle = bgColor;
                ctx.fill();
                
                // –û–±–≤–æ–¥–∫–∞ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Å—Ç–∞—Ç—É—Å–∞ –≤–µ—Ä—à–∏–Ω—ã
                if (isActive !== false) { // –∞–∫—Ç–∏–≤–Ω–∞—è –∏–ª–∏ –≤ —Ä–µ–∂–∏–º–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
                    ctx.strokeStyle = isCurrent ? '#ff8c00' : '#667eea';
                    ctx.lineWidth = isCurrent ? 4 : 2;
                } else { // –Ω–µ–∞–∫—Ç–∏–≤–Ω–∞—è –≤ —Ä–µ–∂–∏–º–µ –î–ü
                    ctx.strokeStyle = '#ccc';
                    ctx.lineWidth = 1;
                }
                ctx.stroke();
                
                console.log(`    –ö—Ä—É–≥ –Ω–∞—Ä–∏—Å–æ–≤–∞–Ω –¥–ª—è ${label}`);
                
                // –ë—É–∫–≤–∞ –≤–µ—Ä—à–∏–Ω—ã - —Å–µ—Ä–∞—è –¥–ª—è –Ω–µ–∞–∫—Ç–∏–≤–Ω—ã—Ö, —á–µ—Ä–Ω–∞—è –¥–ª—è –∞–∫—Ç–∏–≤–Ω—ã—Ö
                ctx.fillStyle = (isActive !== false) ? '#333' : '#999';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(label, x, y);
                
                console.log(`    –¢–µ–∫—Å—Ç –Ω–∞—Ä–∏—Å–æ–≤–∞–Ω –¥–ª—è ${label}`);
                
                // –ó–Ω–∞—á–µ–Ω–∏–µ –î–ü - —Ç–æ–ª—å–∫–æ –¥–ª—è –∞–∫—Ç–∏–≤–Ω—ã—Ö –≤–µ—Ä—à–∏–Ω —Å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º (–Ω–µ null, –Ω–µ undefined)
                if (value !== undefined && value !== null && isActive !== false) {
                    ctx.beginPath();
                    ctx.arc(x + 25, y - 25, 18, 0, 2 * Math.PI);
                    ctx.fillStyle = '#667eea';
                    ctx.fill();
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(value, x + 25, y - 25);
                    
                    console.log(`    –ó–Ω–∞—á–µ–Ω–∏–µ –î–ü (${value}) –Ω–∞—Ä–∏—Å–æ–≤–∞–Ω–æ –¥–ª—è ${label}`);
                }
                
                console.log(`  drawNode –∑–∞–≤–µ—Ä—à—ë–Ω –¥–ª—è ${label}`);
            } catch (error) {
                console.error(`–û—à–∏–±–∫–∞ –≤ drawNode –¥–ª—è ${label}:`, error);
            }
        }
        
        function drawArrow(x1, y1, x2, y2, color, width) {
            const angle = Math.atan2(y2 - y1, x2 - x1);
            const headlen = 10;
            
            // –£–∫–æ—Ä–∞—á–∏–≤–∞–µ–º –ª–∏–Ω–∏—é —á—Ç–æ–±—ã –Ω–µ –∑–∞—Ö–æ–¥–∏–ª–∞ –≤ –∫—Ä—É–≥–∏
            const startX = x1 + 30 * Math.cos(angle);
            const startY = y1 + 30 * Math.sin(angle);
            const endX = x2 - 30 * Math.cos(angle);
            const endY = y2 - 30 * Math.sin(angle);
            
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.stroke();
            
            // –°—Ç—Ä–µ–ª–∫–∞
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(endX - headlen * Math.cos(angle - Math.PI / 6), 
                       endY - headlen * Math.sin(angle - Math.PI / 6));
            ctx.moveTo(endX, endY);
            ctx.lineTo(endX - headlen * Math.cos(angle + Math.PI / 6), 
                       endY - headlen * Math.sin(angle + Math.PI / 6));
            ctx.stroke();
        }
        
        function startAnimation() {
            console.log('=== startAnimation() –≤—ã–∑–≤–∞–Ω ===');
            reset();
            
            if (animationInterval) {
                console.log('  –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π –∏–Ω—Ç–µ—Ä–≤–∞–ª');
                clearInterval(animationInterval);
            }
            
            console.log(`  –ó–∞–ø—É—Å–∫–∞–µ–º –Ω–æ–≤—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª, –æ—á–µ—Ä–µ–¥—å —Å–æ–¥–µ—Ä–∂–∏—Ç ${animationQueue.length} —à–∞–≥–æ–≤`);
            
            animationInterval = setInterval(() => {
                console.log(`[–ò–Ω—Ç–µ—Ä–≤–∞–ª] Tick: currentStep=${currentStep}, queue.length=${animationQueue.length}`);
                
                if (currentStep >= animationQueue.length) {
                    console.log('[–ò–Ω—Ç–µ—Ä–≤–∞–ª] –ê–Ω–∏–º–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞, –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏–Ω—Ç–µ—Ä–≤–∞–ª');
                    clearInterval(animationInterval);
                    animationInterval = null;
                    return;
                }
                stepForward();
            }, 1500);
            
            console.log('  –ò–Ω—Ç–µ—Ä–≤–∞–ª –∑–∞–ø—É—â–µ–Ω —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π 1500ms');
        }
        
        // –ó–∞–≥—Ä—É–∑–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
        function loadImage(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    sourceImage = img;
                    canvas.width = img.width;
                    canvas.height = img.height;
                    draw();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Ä–µ–∂–∏–º–æ–≤
        function setMode(newMode) {
            mode = newMode;
            selectedNode = null;
            
            document.getElementById('nodeModeBtn').style.background = (mode === 'node') ? '#667eea' : '#ccc';
            document.getElementById('edgeModeBtn').style.background = (mode === 'edge') ? '#667eea' : '#ccc';
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–æ–≤ –Ω–∞ canvas
        canvas.addEventListener('click', (e) => {
            if (dpMode) return; // –í —Ä–µ–∂–∏–º–µ –î–ü –Ω–µ –¥–æ–±–∞–≤–ª—è–µ–º –≤–µ—Ä—à–∏–Ω—ã
            if (!sourceImage) {
                alert('–°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ!');
                return;
            }
            
            const rect = canvas.getBoundingClientRect();
            // –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Å —É—á—ë—Ç–æ–º –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è canvas
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            
            if (mode === 'node') {
                addNode(x, y);
            } else if (mode === 'edge') {
                const node = getNodeAt(x, y);
                if (node) {
                    if (!selectedNode) {
                        selectedNode = node;
                    } else if (selectedNode !== node) {
                        addEdge(selectedNode, node);
                        selectedNode = null;
                    }
                }
            }
        });
        
        function addNode(x, y) {
            const label = String.fromCharCode(nextLetter++);
            // –ó–Ω–∞—á–µ–Ω–∏—è –≤–µ—Ä—à–∏–Ω –±—É–¥—É—Ç –≤—ã—á–∏—Å–ª–µ–Ω—ã –ø—Ä–∏ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–∏ –î–ü-–≥—Ä–∞—Ñ–∞
            nodes.push({ label, x, y });
            draw();
        }
        
        function addEdge(from, to) {
            // –í–µ—Å–∞ —Ä—ë–±–µ—Ä –±—É–¥—É—Ç –≤—ã—á–∏—Å–ª–µ–Ω—ã –ø—Ä–∏ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–∏ –î–ü-–≥—Ä–∞—Ñ–∞
            edges.push({ from, to });
            draw();
        }
        
        function getNodeAt(x, y) {
            return nodes.find(n => Math.hypot(n.x - x, n.y - y) < 20);
        }
        
        function clearGraph() {
            if (confirm('–û—á–∏—Å—Ç–∏—Ç—å –≥—Ä–∞—Ñ?')) {
                nodes = [];
                edges = [];
                selectedNode = null;
                nextLetter = 65;
                dpMode = false;
                draw();
            }
        }
        
        // –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –î–ü-–≥—Ä–∞—Ñ–∞ –∏–∑ –æ—Ç–º–µ—á–µ–Ω–Ω—ã—Ö –≤–µ—Ä—à–∏–Ω
        function buildDPGraph() {
            if (nodes.length === 0) {
                alert('–î–æ–±–∞–≤—å—Ç–µ –≤–µ—Ä—à–∏–Ω—ã!');
                return;
            }
            
            // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –æ—Ç–º–µ—á–µ–Ω–Ω—ã–µ –≤–µ—Ä—à–∏–Ω—ã –≤ –≥—Ä–∞—Ñ –¥–ª—è –î–ü
            graph.nodes = nodes.map((n, index) => ({
                id: n.label,
                x: n.x,
                y: n.y,
                level: index // –í—Ä–µ–º–µ–Ω–Ω–æ, –±—É–¥–µ—Ç –ø–µ—Ä–µ—Å—á–∏—Ç–∞–Ω–æ
            }));
            
            graph.edges = edges.map(e => ({
                from: e.from.label,
                to: e.to.label
            }));
            
            // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —É—Ä–æ–≤–Ω–∏ (—Ç–æ–ø–æ–ª–æ–≥–∏—á–µ—Å–∫–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞)
            calculateLevels();
            
            // –í—ã–≤–æ–¥–∏–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤—Å–µ—Ö –≤–µ—Ä—à–∏–Ω
            console.log('–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤–µ—Ä—à–∏–Ω:');
            graph.nodes.forEach(n => {
                console.log(`  ${n.id}: x=${Math.round(n.x)}, y=${Math.round(n.y)}, level=${n.level}`);
            });
            
            dpMode = true;
            reset();
            alert('–î–ü-–≥—Ä–∞—Ñ –ø–æ—Å—Ç—Ä–æ–µ–Ω! –¢–µ–ø–µ—Ä—å –º–æ–∂–Ω–æ –∑–∞–ø—É—Å—Ç–∏—Ç—å –∞–Ω–∏–º–∞—Ü–∏—é.');
        }
        
        function calculateLevels() {
            // –ü—Ä–æ—Å—Ç–æ–π –∞–ª–≥–æ—Ä–∏—Ç–º: —É—Ä–æ–≤–µ–Ω—å = –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å –≤—Ö–æ–¥—è—â–∏—Ö + 1
            const levels = {};
            const inDegree = {};
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
            graph.nodes.forEach(node => {
                levels[node.id] = 0;
                inDegree[node.id] = 0;
            });
            
            // –ü–æ–¥—Å—á–µ—Ç –≤—Ö–æ–¥—è—â–∏—Ö —Ä—ë–±–µ—Ä
            graph.edges.forEach(edge => {
                inDegree[edge.to]++;
            });
            
            // –ù–∞—Ö–æ–¥–∏–º –Ω–∞—á–∞–ª—å–Ω—ã–µ –≤–µ—Ä—à–∏–Ω—ã (–±–µ–∑ –≤—Ö–æ–¥—è—â–∏—Ö —Ä—ë–±–µ—Ä)
            let queue = graph.nodes.filter(n => inDegree[n.id] === 0).map(n => n.id);
            
            while (queue.length > 0) {
                const current = queue.shift();
                const outgoing = graph.edges.filter(e => e.from === current);
                
                outgoing.forEach(edge => {
                    levels[edge.to] = Math.max(levels[edge.to], levels[current] + 1);
                    inDegree[edge.to]--;
                    if (inDegree[edge.to] === 0) {
                        queue.push(edge.to);
                    }
                });
            }
            
            // –ü—Ä–∏–º–µ–Ω—è–µ–º —É—Ä–æ–≤–Ω–∏
            graph.nodes.forEach(node => {
                node.level = levels[node.id];
            });
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        if (graph.nodes.length > 0) {
            dpMode = true;
            reset();
        }
    </script>
</body>
</html>
