<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–î–µ—Ä–µ–≤–æ –ø—É—Ç–µ–π - –Ø–±–ª–æ–∫–∏ –Ω–∞ –≤–µ—Ç–∫–∞—Ö</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            padding: 15px;
            overflow: hidden;
        }
        
        .header {
            text-align: center;
            color: white;
            margin-bottom: 12px;
        }
        
        .header h1 {
            font-size: 26px;
            margin-bottom: 5px;
        }
        
        .header p {
            font-size: 14px;
        }
        
        .main-container {
            display: flex;
            gap: 15px;
            max-width: 100%;
            height: calc(100vh - 120px);
            margin: 0 auto;
        }
        
        .canvas-container {
            flex: 2;
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .sidebar {
            flex: 0 0 380px;
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        canvas {
            display: block;
            width: 100%;
            flex: 1;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            background: linear-gradient(to bottom, #f8f9fa 0%, #ffffff 100%);
        }
        
        .info-section {
            margin-bottom: 15px;
            padding-bottom: 12px;
            border-bottom: 2px solid #f0f0f0;
        }
        
        .info-section:last-child {
            border-bottom: none;
        }
        
        .info-section h3 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .count-display {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 15px;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        .count-display .number {
            font-size: 36px;
            font-weight: bold;
            display: block;
            margin-bottom: 3px;
        }
        
        .count-display .label {
            font-size: 14px;
            opacity: 0.9;
        }
        
        .paths-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
            flex: 1;
            overflow-y: auto;
            max-height: 300px;
        }
        
        .path-item {
            background: linear-gradient(to right, #f8f9fa, #ffffff);
            padding: 8px 10px;
            border-radius: 6px;
            border-left: 3px solid #27ae60;
            font-size: 13px;
            transition: all 0.3s;
        }
        
        .path-item:hover {
            transform: translateX(5px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .legend {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }
        
        .legend-circle {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid #333;
            flex-shrink: 0;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üå≥ –î–µ—Ä–µ–≤–æ –≤—Å–µ—Ö –ø—É—Ç–µ–π</h1>
        <p>–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –º–µ—Ç–æ–¥–æ–º –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –¥–µ—Ä–µ–≤–∞ –ø—É—Ç–µ–π</p>
    </div>
    
    <div class="main-container">
        <div class="canvas-container">
            <canvas id="canvas"></canvas>
        </div>
        
        <div class="sidebar">
            <div class="count-display">
                <span class="number" id="totalCount">0</span>
                <span class="label">–≤—Å–µ–≥–æ –ø—É—Ç–µ–π –Ω–∞–π–¥–µ–Ω–æ</span>
            </div>
            
            <div class="info-section">
                <h3>üìä –ü—Ä–∏–Ω—Ü–∏–ø –º–µ—Ç–æ–¥–∞</h3>
                <p style="font-size: 14px; line-height: 1.6; color: #555;">
                    –°—Ç—Ä–æ–∏–º –¥–µ—Ä–µ–≤–æ, –≥–¥–µ –∫–∞–∂–¥—ã–π –ø—É—Ç—å –æ—Ç –Ω–∞—á–∞–ª–∞ –¥–æ –∫–æ–Ω—Ü–∞ ‚Äî —ç—Ç–æ –æ—Ç–¥–µ–ª—å–Ω–∞—è –≤–µ—Ç–∫–∞. 
                    <strong>–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—É—Ç–µ–π = –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª–∏—Å—Ç—å–µ–≤ (–∫–æ–Ω–µ—á–Ω—ã—Ö —Ç–æ—á–µ–∫)</strong> –Ω–∞ –¥–µ—Ä–µ–≤–µ.
                </p>
            </div>
            
            <div class="info-section">
                <h3>üé® –õ–µ–≥–µ–Ω–¥–∞</h3>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-circle" style="background: #e74c3c; border-color: #c0392b;"></div>
                        <span>–ù–∞—á–∞–ª—å–Ω—ã–π —É–∑–µ–ª</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-circle" style="background: #3498db; border-color: #2980b9;"></div>
                        <span>–ü—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ —É–∑–ª—ã</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-circle" style="background: #2ecc71; border-color: #27ae60;"></div>
                        <span>–ö–æ–Ω–µ—á–Ω—ã–µ —É–∑–ª—ã (–ª–∏—Å—Ç—å—è)</span>
                    </div>
                </div>
            </div>
            
            <div class="info-section">
                <h3>üìù –í—Å–µ –ø—É—Ç–∏ (<span id="pathCount">0</span>)</h3>
                <div class="paths-list" id="pathsList"></div>
            </div>
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let paths = [];
        let startNode = 'A';
        let endNode = 'H';
        
        // –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ localStorage –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–∏–º–µ—Ä
        function loadData() {
            const savedData = localStorage.getItem('treeGraphData');
            
            if (savedData) {
                const data = JSON.parse(savedData);
                const graph = data.graph;
                startNode = data.start;
                endNode = data.end;
                
                // –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ –ø—É—Ç–∏
                paths = findAllPaths(graph, startNode, endNode);
                
                console.log('–ó–∞–≥—Ä—É–∂–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –∏–∑ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞');
                console.log('–ù–∞–π–¥–µ–Ω–æ –ø—É—Ç–µ–π:', paths.length);
            } else {
                // –ü—Ä–∏–º–µ—Ä –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
                paths = [
                    ['A', 'B', 'E', 'G', 'H'],
                    ['A', 'B', 'E', 'H'],
                    ['A', 'C', 'E', 'G', 'H'],
                    ['A', 'C', 'E', 'H'],
                    ['A', 'C', 'F', 'G', 'H'],
                    ['A', 'C', 'F', 'H'],
                    ['A', 'D', 'F', 'G', 'H'],
                    ['A', 'D', 'F', 'H']
                ];
                console.log('–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ø—Ä–∏–º–µ—Ä –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é');
            }
        }
        
        // –ü–æ–∏—Å–∫ –≤—Å–µ—Ö –ø—É—Ç–µ–π (DFS)
        function findAllPaths(graph, start, end) {
            const allPaths = [];
            const visited = new Set();
            
            // –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ adjacency list
            const adjList = {};
            graph.edges.forEach(edge => {
                if (!adjList[edge.from]) adjList[edge.from] = [];
                adjList[edge.from].push(edge.to);
            });
            
            function dfs(node, path) {
                if (node === end) {
                    allPaths.push([...path]);
                    return;
                }
                
                visited.add(node);
                
                if (adjList[node]) {
                    adjList[node].forEach(neighbor => {
                        if (!visited.has(neighbor)) {
                            path.push(neighbor);
                            dfs(neighbor, path);
                            path.pop();
                        }
                    });
                }
                
                visited.delete(node);
            }
            
            dfs(start, [start]);
            return allPaths;
        }
        
        // –í—ã—á–∏—Å–ª—è–µ–º –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è –¥–µ—Ä–µ–≤–∞
        let treeNodes = [];
        
        function buildTree() {
            treeNodes = [];
            const padding = 60;
            const topPadding = 40;
            const bottomPadding = 50;
            
            // –°—Ç—Ä–æ–∏–º –¥–µ—Ä–µ–≤–æ –ø—Ä–µ—Ñ–∏–∫—Å–æ–≤
            const tree = {};
            let rootKey = null;
            
            paths.forEach((path, pathIndex) => {
                let currentKey = '';
                path.forEach((node, depth) => {
                    const parentKey = currentKey;
                    currentKey = currentKey ? `${currentKey}->${node}` : node;
                    
                    if (depth === 0) rootKey = currentKey;
                    
                    if (!tree[currentKey]) {
                        tree[currentKey] = {
                            label: node,
                            depth: depth,
                            parentKey: parentKey,
                            children: [],
                            pathsThrough: [],
                            isLeaf: false,
                            x: 0,
                            y: 0
                        };
                    }
                    
                    tree[currentKey].pathsThrough.push(pathIndex);
                    
                    if (depth === path.length - 1) {
                        tree[currentKey].isLeaf = true;
                    }
                    
                    if (parentKey && !tree[parentKey].children.includes(currentKey)) {
                        tree[parentKey].children.push(currentKey);
                    }
                });
            });
            
            // –ù–∞—Ö–æ–¥–∏–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –≥–ª—É–±–∏–Ω—É
            let maxDepth = 0;
            Object.values(tree).forEach(node => {
                if (node.depth > maxDepth) maxDepth = node.depth;
            });
            
            const availableHeight = canvas.height - topPadding - bottomPadding;
            const levelHeight = maxDepth > 0 ? Math.min(availableHeight / maxDepth, 100) : 100;
            
            // –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ –ª–∏—Å—Ç—å—è –∏ –ø—Ä–∏—Å–≤–∞–∏–≤–∞–µ–º –∏–º –Ω–æ–º–µ—Ä–∞
            const leaves = Object.keys(tree).filter(key => tree[key].isLeaf);
            leaves.forEach((leafKey, index) => {
                tree[leafKey].pathNumber = index + 1;
            });
            
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º DFS –æ–±—Ö–æ–¥ –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è —É–∑–ª–æ–≤ —Å–ª–µ–≤–∞ –Ω–∞–ø—Ä–∞–≤–æ
            // –≠—Ç–æ –º–∏–Ω–∏–º–∏–∑–∏—Ä—É–µ—Ç –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è —Ä—ë–±–µ—Ä
            const minNodeSpacing = 80; // –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É —É–∑–ª–∞–º–∏
            let currentX = padding;
            
            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º Y –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –¥–ª—è –≤—Å–µ—Ö —É–∑–ª–æ–≤
            Object.values(tree).forEach(node => {
                node.y = topPadding + node.depth * levelHeight;
            });
            
            // DFS –æ–±—Ö–æ–¥ –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ X –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
            function dfsLayout(nodeKey, visited = new Set()) {
                if (visited.has(nodeKey)) return;
                visited.add(nodeKey);
                
                const node = tree[nodeKey];
                
                if (node.children.length === 0) {
                    // –õ–∏—Å—Ç - —Ä–∞–∑–º–µ—â–∞–µ–º —Å–ª–µ–≤–∞ –Ω–∞–ø—Ä–∞–≤–æ
                    node.x = currentX;
                    currentX += minNodeSpacing;
                } else {
                    // –°–Ω–∞—á–∞–ª–∞ —Ä–∞–∑–º–µ—â–∞–µ–º –≤—Å–µ—Ö –¥–µ—Ç–µ–π
                    node.children.forEach(childKey => {
                        dfsLayout(childKey, visited);
                    });
                    
                    // –†–∞–∑–º–µ—â–∞–µ–º —É–∑–µ–ª –ø–æ —Ü–µ–Ω—Ç—Ä—É –º–µ–∂–¥—É –¥–µ—Ç—å–º–∏
                    const childrenX = node.children.map(childKey => tree[childKey].x);
                    const minX = Math.min(...childrenX);
                    const maxX = Math.max(...childrenX);
                    node.x = (minX + maxX) / 2;
                }
            }
            
            // –ù–∞—á–∏–Ω–∞–µ–º –æ–±—Ö–æ–¥ —Å –∫–æ—Ä–Ω—è
            if (rootKey) {
                dfsLayout(rootKey);
            }
            
            // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –≤—Å—ë –¥–µ—Ä–µ–≤–æ
            const allNodes = Object.values(tree);
            const minTreeX = Math.min(...allNodes.map(n => n.x));
            const maxTreeX = Math.max(...allNodes.map(n => n.x));
            const treeWidth = maxTreeX - minTreeX;
            const availableWidth = canvas.width - 2 * padding;
            
            let scale = 1;
            let offsetX = 0;
            
            if (treeWidth > availableWidth) {
                // –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º –µ—Å–ª–∏ –Ω–µ –ø–æ–º–µ—â–∞–µ—Ç—Å—è
                scale = availableWidth / treeWidth;
                offsetX = padding;
            } else {
                // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º
                offsetX = (canvas.width - treeWidth) / 2;
            }
            
            // –ü—Ä–∏–º–µ–Ω—è–µ–º –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ —Å–º–µ—â–µ–Ω–∏–µ
            allNodes.forEach(node => {
                node.x = offsetX + (node.x - minTreeX) * scale;
            });
            
            // –§–∏–Ω–∞–ª—å–Ω–∞—è –∫–æ—Ä—Ä–µ–∫—Ü–∏—è: –ø—Ä–æ–≤–µ—Ä—è–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –Ω–∞ –∫–∞–∂–¥–æ–º —É—Ä–æ–≤–Ω–µ
            const nodesByDepth = {};
            for (let depth = 0; depth <= maxDepth; depth++) {
                nodesByDepth[depth] = [];
            }
            
            allNodes.forEach(node => {
                node.key = node.key || Object.keys(tree).find(k => tree[k] === node);
                nodesByDepth[node.depth].push(node);
            });
            
            // –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –∫–∞–∂–¥—ã–π —É—Ä–æ–≤–µ–Ω—å
            for (let depth = 0; depth <= maxDepth; depth++) {
                const nodesAtLevel = nodesByDepth[depth];
                nodesAtLevel.sort((a, b) => a.x - b.x);
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è
                let needsAdjustment = false;
                for (let i = 1; i < nodesAtLevel.length; i++) {
                    if (nodesAtLevel[i].x - nodesAtLevel[i-1].x < minNodeSpacing * 0.8) {
                        needsAdjustment = true;
                        break;
                    }
                }
                
                if (needsAdjustment && nodesAtLevel.length > 1) {
                    // –ü–µ—Ä–µ—Ä–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ–º —É–∑–ª—ã —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ –Ω–∞ —ç—Ç–æ–º —É—Ä–æ–≤–Ω–µ
                    const levelStart = nodesAtLevel[0].x;
                    const levelEnd = nodesAtLevel[nodesAtLevel.length - 1].x;
                    const levelWidth = levelEnd - levelStart;
                    const neededWidth = (nodesAtLevel.length - 1) * minNodeSpacing * 0.9;
                    
                    if (levelWidth < neededWidth) {
                        // –†–∞—Å—à–∏—Ä—è–µ–º —É—Ä–æ–≤–µ–Ω—å
                        const spacing = minNodeSpacing * 0.9;
                        const totalWidth = spacing * (nodesAtLevel.length - 1);
                        const startX = (canvas.width - totalWidth) / 2;
                        
                        nodesAtLevel.forEach((node, idx) => {
                            node.x = startX + idx * spacing;
                        });
                    }
                }
            }
            
            // –î–æ–±–∞–≤–ª—è–µ–º –≤—Å–µ —É–∑–ª—ã –≤ treeNodes
            Object.keys(tree).forEach(key => {
                treeNodes.push(tree[key]);
            });
        }
        
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            buildTree();
            draw();
        }
        
        window.addEventListener('resize', resizeCanvas);
        setTimeout(resizeCanvas, 100);
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // –°–æ–∑–¥–∞—ë–º –∫–∞—Ä—Ç—É —É–∑–ª–æ–≤ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞
            const nodeMap = {};
            treeNodes.forEach(node => {
                nodeMap[node.key] = node;
            });
            
            // –†–∏—Å—É–µ–º –≤–µ—Ç–∫–∏ (—Ä—ë–±—Ä–∞) - –æ—Ç —Ä–æ–¥–∏—Ç–µ–ª–µ–π –∫ –¥–µ—Ç—è–º
            const drawnEdges = new Set();
            
            treeNodes.forEach(node => {
                if (node.children && node.children.length > 0) {
                    node.children.forEach(childKey => {
                        const child = nodeMap[childKey];
                        if (child) {
                            const edgeKey = `${node.key}->${childKey}`;
                            if (!drawnEdges.has(edgeKey)) {
                                drawnEdges.add(edgeKey);
                                
                                // –í—ã—á–∏—Å–ª—è–µ–º —Ä–∞–¥–∏—É—Å—ã —É–∑–ª–æ–≤
                                const nodeRadius = node.depth === 0 ? 20 : 16;
                                const childRadius = child.isLeaf ? 14 : 16;
                                
                                // –í—ã—á–∏—Å–ª—è–µ–º —É–≥–æ–ª –º–µ–∂–¥—É —É–∑–ª–∞–º–∏
                                const angle = Math.atan2(child.y - node.y, child.x - node.x);
                                
                                // –ù–∞—á–∞–ª–æ –ª–∏–Ω–∏–∏ - –Ω–∞ –≥—Ä–∞–Ω–∏—Ü–µ —Ä–æ–¥–∏—Ç–µ–ª—è
                                const startX = node.x + nodeRadius * Math.cos(angle);
                                const startY = node.y + nodeRadius * Math.sin(angle);
                                
                                // –ö–æ–Ω–µ—Ü –ª–∏–Ω–∏–∏ - –Ω–∞ –≥—Ä–∞–Ω–∏—Ü–µ —Ä–µ–±—ë–Ω–∫–∞
                                const endX = child.x - childRadius * Math.cos(angle);
                                const endY = child.y - childRadius * Math.sin(angle);
                                
                                // –í–µ—Ç–∫–∞ –¥–µ—Ä–µ–≤–∞
                                ctx.beginPath();
                                ctx.moveTo(startX, startY);
                                ctx.lineTo(endX, endY);
                                
                                // –ì—Ä–∞–¥–∏–µ–Ω—Ç –¥–ª—è –≤–µ—Ç–∫–∏
                                const gradient = ctx.createLinearGradient(startX, startY, endX, endY);
                                gradient.addColorStop(0, '#95a5a6');
                                gradient.addColorStop(1, '#7f8c8d');
                                
                                ctx.strokeStyle = gradient;
                                ctx.lineWidth = 3;
                                ctx.lineCap = 'round';
                                ctx.stroke();
                            }
                        }
                    });
                }
            });
            
            // –†–∏—Å—É–µ–º —É–∑–ª—ã
            treeNodes.forEach(node => {
                if (node.depth === 0) {
                    // –ö–æ—Ä–µ–Ω—å –¥–µ—Ä–µ–≤–∞ (—Å—Ç–∞—Ä—Ç–æ–≤—ã–π —É–∑–µ–ª) - –∫—Ä–∞—Å–Ω—ã–π
                    drawNode(node.x, node.y, node.label, '#e74c3c', 40, true, false);
                } else if (node.isLeaf) {
                    // –õ–∏—Å—Ç—å—è (–∫–æ–Ω–µ—á–Ω—ã–µ —É–∑–ª—ã) - –∑–µ–ª—ë–Ω—ã–µ
                    drawLeaf(node.x, node.y, node.label, node.pathNumber);
                } else {
                    // –ü—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ —É–∑–ª—ã - —Å–∏–Ω–∏–µ
                    drawNode(node.x, node.y, node.label, '#3498db', 32, false, false);
                }
            });
            
            // –ü–æ–¥—Å—á—ë—Ç –∫–æ–Ω–µ—á–Ω—ã—Ö —É–∑–ª–æ–≤ (–ø—É—Ç–µ–π)
            const pathsCount = treeNodes.filter(n => n.isLeaf).length;
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`‚úì –ù–∞–π–¥–µ–Ω–æ –ø—É—Ç–µ–π: ${pathsCount}`, canvas.width / 2, canvas.height - 20);
        }
        
        function drawNode(x, y, label, color, size, isRoot, isLeaf) {
            // –¢–µ–Ω—å
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 8;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
            
            // –ö—Ä—É–≥
            ctx.beginPath();
            ctx.arc(x, y, size / 2, 0, 2 * Math.PI);
            ctx.fillStyle = color;
            ctx.fill();
            
            // –°–±—Ä–æ—Å —Ç–µ–Ω–∏
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            // –û–±–≤–æ–¥–∫–∞
            let strokeColor = '#2d3436';
            let lineWidth = 3;
            if (isRoot) {
                strokeColor = '#c0392b';
                lineWidth = 4;
            } else if (isLeaf) {
                strokeColor = '#27ae60';
                lineWidth = 3;
            } else {
                strokeColor = '#2980b9';
            }
            
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = lineWidth;
            ctx.stroke();
            
            // –ë—É–∫–≤–∞
            ctx.fillStyle = 'white';
            ctx.font = `bold ${Math.max(16, size / 1.8)}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, x, y);
        }
        
        function drawLeaf(x, y, label, pathNumber) {
            // –¢–µ–Ω—å
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
            
            // –ö–æ–Ω–µ—á–Ω—ã–π —É–∑–µ–ª (–ª–∏—Å—Ç)
            ctx.beginPath();
            ctx.arc(x, y, 28, 0, 2 * Math.PI);
            
            // –ì—Ä–∞–¥–∏–µ–Ω—Ç –¥–ª—è –ª–∏—Å—Ç–∞
            const gradient = ctx.createRadialGradient(x - 8, y - 8, 5, x, y, 28);
            gradient.addColorStop(0, '#2ecc71');
            gradient.addColorStop(1, '#27ae60');
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // –°–±—Ä–æ—Å —Ç–µ–Ω–∏
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            // –û–±–≤–æ–¥–∫–∞
            ctx.strokeStyle = '#27ae60';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // –ë—É–∫–≤–∞
            ctx.fillStyle = 'white';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, x, y);
            
            // –ù–æ–º–µ—Ä –ø—É—Ç–∏ –ø–æ–¥ —É–∑–ª–æ–º
            if (pathNumber) {
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(pathNumber, x, y + 42);
            }
        }
        
        // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Å–ø–∏—Å–æ–∫ –ø—É—Ç–µ–π
        function displayPathsList() {
            const listDiv = document.getElementById('pathsList');
            const countDiv = document.getElementById('totalCount');
            const pathCountSpan = document.getElementById('pathCount');
            
            countDiv.textContent = paths.length;
            pathCountSpan.textContent = paths.length;
            
            listDiv.innerHTML = paths.map((path, i) => `
                <div class="path-item">
                    <strong>${i + 1}.</strong> ${path.join(' ‚Üí ')}
                </div>
            `).join('');
        }
        
        loadData();
        displayPathsList();
        resizeCanvas();
    </script>
</body>
</html>
