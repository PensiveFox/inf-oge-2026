<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–î–µ—Ä–µ–≤–æ –ø—É—Ç–µ–π - –Ø–±–ª–æ–∫–∏ –Ω–∞ –≤–µ—Ç–∫–∞—Ö</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            padding: 15px;
            overflow: hidden;
        }
        
        .header {
            text-align: center;
            color: white;
            margin-bottom: 12px;
        }
        
        .header h1 {
            font-size: 26px;
            margin-bottom: 5px;
        }
        
        .header p {
            font-size: 14px;
        }
        
        .main-container {
            display: flex;
            gap: 15px;
            max-width: 100%;
            height: calc(100vh - 120px);
            margin: 0 auto;
        }
        
        .canvas-container {
            flex: 1;
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            justify-content: center;
        }
        
        .controls button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .btn-primary {
            background: #667eea;
            color: white;
        }
        
        .btn-primary:hover {
            background: #5568d3;
        }
        
        .btn-secondary {
            background: #27ae60;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #229954;
        }
        
        .btn-reset {
            background: #e74c3c;
            color: white;
        }
        
        .btn-reset:hover {
            background: #c0392b;
        }
        
        .sidebar {
            flex: 0 0 16.666%;
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        .source-image-overlay {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 33.333%;
            height: 50%;
            background: white;
            border: 3px solid #667eea;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.3);
            z-index: 10;
            padding: 10px;
            display: flex;
            flex-direction: column;
        }
        
        .source-image-overlay h3 {
            margin: 0 0 8px 0;
            color: #2c3e50;
            font-size: 14px;
            font-weight: 600;
        }
        
        .source-image-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            background: #f8f9fa;
        }
        
        .source-image-wrapper img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        
        canvas {
            display: block;
            width: 100%;
            flex: 1;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            background: linear-gradient(to bottom, #f8f9fa 0%, #ffffff 100%);
        }
        
        .info-section {
            margin-bottom: 15px;
            padding-bottom: 12px;
            border-bottom: 2px solid #f0f0f0;
        }
        
        .info-section:last-child {
            border-bottom: none;
        }
        
        .info-section h3 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .count-display {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 15px;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        .count-display .number {
            font-size: 36px;
            font-weight: bold;
            display: block;
            margin-bottom: 3px;
        }
        
        .count-display .label {
            font-size: 14px;
            opacity: 0.9;
        }
        
        .paths-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
            flex: 1;
            overflow-y: auto;
            max-height: 300px;
        }
        
        .path-item {
            background: linear-gradient(to right, #f8f9fa, #ffffff);
            padding: 8px 10px;
            border-radius: 6px;
            border-left: 3px solid #27ae60;
            font-size: 13px;
            transition: all 0.3s;
        }
        
        .path-item:hover {
            transform: translateX(5px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .legend {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }
        
        .legend-circle {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid #333;
            flex-shrink: 0;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üå≥ –î–µ—Ä–µ–≤–æ –≤—Å–µ—Ö –ø—É—Ç–µ–π</h1>
        <p>–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –º–µ—Ç–æ–¥–æ–º –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –¥–µ—Ä–µ–≤–∞ –ø—É—Ç–µ–π</p>
    </div>
    
    <div class="main-container">
        <div class="canvas-container">
            <div class="controls">
                <button class="btn-primary" id="btnStart" onclick="startAnimation()">‚ñ∂Ô∏è –ó–∞–ø—É—Å—Ç–∏—Ç—å –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ</button>
                <button class="btn-secondary" id="btnPause" onclick="pauseAnimation()" disabled>‚è∏Ô∏è –ü–∞—É–∑–∞</button>
                <button class="btn-reset" id="btnReset" onclick="resetAnimation()">üîÑ –°–±—Ä–æ—Å</button>
            </div>
            
            <!-- –ò—Å—Ö–æ–¥–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ–≤–µ—Ä—Ö canvas -->
            <div class="source-image-overlay" id="sourceImageOverlay">
                <h3>üìä –ò—Å—Ö–æ–¥–Ω—ã–π –≥—Ä–∞—Ñ</h3>
                <div class="source-image-wrapper" id="sourceImageWrapper">
                    <p style="color: #999; font-size: 12px; text-align: center; padding: 10px;">–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≥—Ä–∞—Ñ–∞</p>
                </div>
            </div>
            
            <canvas id="canvas"></canvas>
        </div>
        
        <div class="sidebar">
            <div class="count-display">
                <span class="number" id="totalCount">0</span>
                <span class="label">–≤—Å–µ–≥–æ –ø—É—Ç–µ–π –Ω–∞–π–¥–µ–Ω–æ</span>
            </div>
            
            <div class="info-section">
                <h3>üìä –ü—Ä–∏–Ω—Ü–∏–ø –º–µ—Ç–æ–¥–∞</h3>
                <p style="font-size: 14px; line-height: 1.6; color: #555;">
                    –°—Ç—Ä–æ–∏–º –¥–µ—Ä–µ–≤–æ, –≥–¥–µ –∫–∞–∂–¥—ã–π –ø—É—Ç—å –æ—Ç –Ω–∞—á–∞–ª–∞ –¥–æ –∫–æ–Ω—Ü–∞ ‚Äî —ç—Ç–æ –æ—Ç–¥–µ–ª—å–Ω–∞—è –≤–µ—Ç–∫–∞. 
                    <strong>–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—É—Ç–µ–π = –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª–∏—Å—Ç—å–µ–≤ (–∫–æ–Ω–µ—á–Ω—ã—Ö —Ç–æ—á–µ–∫)</strong> –Ω–∞ –¥–µ—Ä–µ–≤–µ.
                </p>
            </div>
            
            <div class="info-section">
                <h3>üé® –õ–µ–≥–µ–Ω–¥–∞</h3>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-circle" style="background: #e74c3c; border-color: #c0392b;"></div>
                        <span>–ù–∞—á–∞–ª—å–Ω—ã–π —É–∑–µ–ª</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-circle" style="background: #3498db; border-color: #2980b9;"></div>
                        <span>–ü—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ —É–∑–ª—ã</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-circle" style="background: #2ecc71; border-color: #27ae60;"></div>
                        <span>–ö–æ–Ω–µ—á–Ω—ã–µ —É–∑–ª—ã (–ª–∏—Å—Ç—å—è)</span>
                    </div>
                </div>
            </div>
            
            <div class="info-section">
                <h3>üìù –í—Å–µ –ø—É—Ç–∏ (<span id="pathCount">0</span>)</h3>
                <div class="paths-list" id="pathsList"></div>
            </div>
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let paths = [];
        let startNode = 'A';
        let endNode = 'H';
        let sourceImage = null;
        let animationInterval = null;
        let treeNodes = [];
        let animationSequence = []; // –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å —É–∑–ª–æ–≤ –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏
        let isAnimating = false;
        let isPaused = false;
        let currentLevel = 0; // –¢–µ–∫—É—â–∏–π —É—Ä–æ–≤–µ–Ω—å –≥–ª—É–±–∏–Ω—ã
        let maxPathLength = 0; // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞ –ø—É—Ç–∏
        let currentNodeIndexInLevel = 0; // –ò–Ω–¥–µ–∫—Å —É–∑–ª–∞ –≤ —Ç–µ–∫—É—â–µ–º —É—Ä–æ–≤–Ω–µ
        
        // –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ localStorage –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–∏–º–µ—Ä
        function loadData() {
            const savedData = localStorage.getItem('treeGraphData');
            
            if (savedData) {
                const data = JSON.parse(savedData);
                const graph = data.graph;
                startNode = data.start;
                endNode = data.end;
                
                // –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ –ø—É—Ç–∏
                paths = findAllPaths(graph, startNode, endNode);
                
                // –ó–∞–≥—Ä—É–∂–∞–µ–º –∏—Å—Ö–æ–¥–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –µ—Å–ª–∏ –µ—Å—Ç—å
                const savedImage = localStorage.getItem('sourceGraphImage');
                if (savedImage) {
                    displaySourceImage(savedImage);
                }
                
                console.log('–ó–∞–≥—Ä—É–∂–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –∏–∑ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞');
                console.log('–ù–∞–π–¥–µ–Ω–æ –ø—É—Ç–µ–π:', paths.length);
            } else {
                // –ü—Ä–∏–º–µ—Ä –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
                paths = [
                    ['A', 'B', 'E', 'G', 'H'],
                    ['A', 'B', 'E', 'H'],
                    ['A', 'C', 'E', 'G', 'H'],
                    ['A', 'C', 'E', 'H'],
                    ['A', 'C', 'F', 'G', 'H'],
                    ['A', 'C', 'F', 'H'],
                    ['A', 'D', 'F', 'G', 'H'],
                    ['A', 'D', 'F', 'H']
                ];
                console.log('–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ø—Ä–∏–º–µ—Ä –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é');
            }
        }
        
        // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º –∏—Å—Ö–æ–¥–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
        function displaySourceImage(imageDataUrl) {
            const wrapper = document.getElementById('sourceImageWrapper');
            wrapper.innerHTML = '';
            
            const img = document.createElement('img');
            img.src = imageDataUrl;
            img.onload = function() {
                sourceImage = img;
            };
            wrapper.appendChild(img);
        }
        
        // –ü–æ–∏—Å–∫ –≤—Å–µ—Ö –ø—É—Ç–µ–π (DFS)
        function findAllPaths(graph, start, end) {
            const allPaths = [];
            const visited = new Set();
            
            // –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ adjacency list
            const adjList = {};
            graph.edges.forEach(edge => {
                if (!adjList[edge.from]) adjList[edge.from] = [];
                adjList[edge.from].push(edge.to);
            });
            
            function dfs(node, path) {
                if (node === end) {
                    allPaths.push([...path]);
                    return;
                }
                
                visited.add(node);
                
                if (adjList[node]) {
                    adjList[node].forEach(neighbor => {
                        if (!visited.has(neighbor)) {
                            path.push(neighbor);
                            dfs(neighbor, path);
                            path.pop();
                        }
                    });
                }
                
                visited.delete(node);
            }
            
            dfs(start, [start]);
            return allPaths;
        }
        
        // –í—ã—á–∏—Å–ª—è–µ–º –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è –¥–µ—Ä–µ–≤–∞
        function buildTree() {
            treeNodes = [];
            const padding = 60;
            const topPadding = 60;
            const bottomPadding = 50;
            const rightPadding = canvas.width * 0.37; // –û—Ç—Å—Ç—É–ø —Å–ø—Ä–∞–≤–∞ –¥–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
            
            // –°—Ç—Ä–æ–∏–º –¥–µ—Ä–µ–≤–æ –ø—Ä–µ—Ñ–∏–∫—Å–æ–≤
            const tree = {};
            let rootKey = null;
            
            paths.forEach((path, pathIndex) => {
                let currentKey = '';
                path.forEach((node, depth) => {
                    const parentKey = currentKey;
                    currentKey = currentKey ? `${currentKey}->${node}` : node;
                    
                    if (depth === 0) rootKey = currentKey;
                    
                    if (!tree[currentKey]) {
                        tree[currentKey] = {
                            label: node,
                            depth: depth,
                            parentKey: parentKey,
                            children: [],
                            pathsThrough: [],
                            isLeaf: false,
                            x: 0,
                            y: 0
                        };
                    }
                    
                    tree[currentKey].pathsThrough.push(pathIndex);
                    
                    if (depth === path.length - 1) {
                        tree[currentKey].isLeaf = true;
                    }
                    
                    if (parentKey && !tree[parentKey].children.includes(currentKey)) {
                        tree[parentKey].children.push(currentKey);
                    }
                });
            });
            
            // –ù–∞—Ö–æ–¥–∏–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –≥–ª—É–±–∏–Ω—É
            let maxDepth = 0;
            Object.values(tree).forEach(node => {
                if (node.depth > maxDepth) maxDepth = node.depth;
            });
            
            const availableHeight = canvas.height - topPadding - bottomPadding;
            const levelHeight = maxDepth > 0 ? Math.min(availableHeight / maxDepth, 100) : 100;
            
            // –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ –ª–∏—Å—Ç—å—è –∏ –ø—Ä–∏—Å–≤–∞–∏–≤–∞–µ–º –∏–º –Ω–æ–º–µ—Ä–∞
            const leaves = Object.keys(tree).filter(key => tree[key].isLeaf);
            leaves.forEach((leafKey, index) => {
                tree[leafKey].pathNumber = index + 1;
            });
            
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º DFS –æ–±—Ö–æ–¥ –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è —É–∑–ª–æ–≤ —Å–ª–µ–≤–∞ –Ω–∞–ø—Ä–∞–≤–æ
            // –≠—Ç–æ –º–∏–Ω–∏–º–∏–∑–∏—Ä—É–µ—Ç –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è —Ä—ë–±–µ—Ä
            const minNodeSpacing = 80; // –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É —É–∑–ª–∞–º–∏
            let currentX = padding;
            
            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º Y –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –¥–ª—è –≤—Å–µ—Ö —É–∑–ª–æ–≤
            Object.values(tree).forEach(node => {
                node.y = topPadding + node.depth * levelHeight;
            });
            
            // DFS –æ–±—Ö–æ–¥ –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ X –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
            function dfsLayout(nodeKey, visited = new Set()) {
                if (visited.has(nodeKey)) return;
                visited.add(nodeKey);
                
                const node = tree[nodeKey];
                
                if (node.children.length === 0) {
                    // –õ–∏—Å—Ç - —Ä–∞–∑–º–µ—â–∞–µ–º —Å–ª–µ–≤–∞ –Ω–∞–ø—Ä–∞–≤–æ
                    node.x = currentX;
                    currentX += minNodeSpacing;
                } else {
                    // –°–Ω–∞—á–∞–ª–∞ —Ä–∞–∑–º–µ—â–∞–µ–º –≤—Å–µ—Ö –¥–µ—Ç–µ–π
                    node.children.forEach(childKey => {
                        dfsLayout(childKey, visited);
                    });
                    
                    // –†–∞–∑–º–µ—â–∞–µ–º —É–∑–µ–ª –ø–æ —Ü–µ–Ω—Ç—Ä—É –º–µ–∂–¥—É –¥–µ—Ç—å–º–∏
                    const childrenX = node.children.map(childKey => tree[childKey].x);
                    const minX = Math.min(...childrenX);
                    const maxX = Math.max(...childrenX);
                    node.x = (minX + maxX) / 2;
                }
            }
            
            // –ù–∞—á–∏–Ω–∞–µ–º –æ–±—Ö–æ–¥ —Å –∫–æ—Ä–Ω—è
            if (rootKey) {
                dfsLayout(rootKey);
            }
            
            // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –≤—Å—ë –¥–µ—Ä–µ–≤–æ —Å —É—á—ë—Ç–æ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å–ø—Ä–∞–≤–∞
            const allNodes = Object.values(tree);
            const minTreeX = Math.min(...allNodes.map(n => n.x));
            const maxTreeX = Math.max(...allNodes.map(n => n.x));
            const treeWidth = maxTreeX - minTreeX;
            const availableWidth = canvas.width - padding - rightPadding;
            
            let scale = 1;
            let offsetX = 0;
            
            if (treeWidth > availableWidth) {
                // –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º –µ—Å–ª–∏ –Ω–µ –ø–æ–º–µ—â–∞–µ—Ç—Å—è
                scale = availableWidth / treeWidth;
                offsetX = padding;
            } else {
                // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –≤ –¥–æ—Å—Ç—É–ø–Ω–æ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ (—Å–ª–µ–≤–∞ –æ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è)
                offsetX = padding + (availableWidth - treeWidth) / 2;
            }
            
            // –ü—Ä–∏–º–µ–Ω—è–µ–º –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ —Å–º–µ—â–µ–Ω–∏–µ
            allNodes.forEach(node => {
                node.x = offsetX + (node.x - minTreeX) * scale;
            });
            
            // –§–∏–Ω–∞–ª—å–Ω–∞—è –∫–æ—Ä—Ä–µ–∫—Ü–∏—è: –ø—Ä–æ–≤–µ—Ä—è–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –Ω–∞ –∫–∞–∂–¥–æ–º —É—Ä–æ–≤–Ω–µ
            const nodesByDepth = {};
            for (let depth = 0; depth <= maxDepth; depth++) {
                nodesByDepth[depth] = [];
            }
            
            allNodes.forEach(node => {
                node.key = node.key || Object.keys(tree).find(k => tree[k] === node);
                nodesByDepth[node.depth].push(node);
            });
            
            // –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –∫–∞–∂–¥—ã–π —É—Ä–æ–≤–µ–Ω—å
            for (let depth = 0; depth <= maxDepth; depth++) {
                const nodesAtLevel = nodesByDepth[depth];
                nodesAtLevel.sort((a, b) => a.x - b.x);
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è
                let needsAdjustment = false;
                for (let i = 1; i < nodesAtLevel.length; i++) {
                    if (nodesAtLevel[i].x - nodesAtLevel[i-1].x < minNodeSpacing * 0.8) {
                        needsAdjustment = true;
                        break;
                    }
                }
                
                if (needsAdjustment && nodesAtLevel.length > 1) {
                    // –ü–µ—Ä–µ—Ä–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ–º —É–∑–ª—ã —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ –Ω–∞ —ç—Ç–æ–º —É—Ä–æ–≤–Ω–µ
                    const levelStart = nodesAtLevel[0].x;
                    const levelEnd = nodesAtLevel[nodesAtLevel.length - 1].x;
                    const levelWidth = levelEnd - levelStart;
                    const neededWidth = (nodesAtLevel.length - 1) * minNodeSpacing * 0.9;
                    
                    if (levelWidth < neededWidth) {
                        // –†–∞—Å—à–∏—Ä—è–µ–º —É—Ä–æ–≤–µ–Ω—å
                        const spacing = minNodeSpacing * 0.9;
                        const totalWidth = spacing * (nodesAtLevel.length - 1);
                        const startX = (canvas.width - totalWidth) / 2;
                        
                        nodesAtLevel.forEach((node, idx) => {
                            node.x = startX + idx * spacing;
                        });
                    }
                }
            }
            
            // –î–æ–±–∞–≤–ª—è–µ–º –≤—Å–µ —É–∑–ª—ã –≤ treeNodes
            Object.keys(tree).forEach(key => {
                treeNodes.push(tree[key]);
            });
        }
        
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            buildTree();
            draw();
        }
        
        window.addEventListener('resize', resizeCanvas);
        setTimeout(resizeCanvas, 100);
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // –°–æ–∑–¥–∞—ë–º –∫–∞—Ä—Ç—É —É–∑–ª–æ–≤ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞
            const nodeMap = {};
            treeNodes.forEach(node => {
                nodeMap[node.key] = node;
            });
            
            // –†–∏—Å—É–µ–º –≤–µ—Ç–∫–∏ (—Ä—ë–±—Ä–∞) - –æ—Ç —Ä–æ–¥–∏—Ç–µ–ª–µ–π –∫ –¥–µ—Ç—è–º
            const drawnEdges = new Set();
            
            treeNodes.forEach(node => {
                if (node.children && node.children.length > 0) {
                    node.children.forEach(childKey => {
                        const child = nodeMap[childKey];
                        if (child) {
                            const edgeKey = `${node.key}->${childKey}`;
                            if (!drawnEdges.has(edgeKey)) {
                                drawnEdges.add(edgeKey);
                                
                                // –í—ã—á–∏—Å–ª—è–µ–º —Ä–∞–¥–∏—É—Å—ã —É–∑–ª–æ–≤
                                const nodeRadius = node.depth === 0 ? 20 : 16;
                                const childRadius = child.isLeaf ? 14 : 16;
                                
                                // –í—ã—á–∏—Å–ª—è–µ–º —É–≥–æ–ª –º–µ–∂–¥—É —É–∑–ª–∞–º–∏
                                const angle = Math.atan2(child.y - node.y, child.x - node.x);
                                
                                // –ù–∞—á–∞–ª–æ –ª–∏–Ω–∏–∏ - –Ω–∞ –≥—Ä–∞–Ω–∏—Ü–µ —Ä–æ–¥–∏—Ç–µ–ª—è
                                const startX = node.x + nodeRadius * Math.cos(angle);
                                const startY = node.y + nodeRadius * Math.sin(angle);
                                
                                // –ö–æ–Ω–µ—Ü –ª–∏–Ω–∏–∏ - –Ω–∞ –≥—Ä–∞–Ω–∏—Ü–µ —Ä–µ–±—ë–Ω–∫–∞
                                const endX = child.x - childRadius * Math.cos(angle);
                                const endY = child.y - childRadius * Math.sin(angle);
                                
                                // –í–µ—Ç–∫–∞ –¥–µ—Ä–µ–≤–∞
                                ctx.beginPath();
                                ctx.moveTo(startX, startY);
                                ctx.lineTo(endX, endY);
                                
                                // –ì—Ä–∞–¥–∏–µ–Ω—Ç –¥–ª—è –≤–µ—Ç–∫–∏
                                const gradient = ctx.createLinearGradient(startX, startY, endX, endY);
                                gradient.addColorStop(0, '#95a5a6');
                                gradient.addColorStop(1, '#7f8c8d');
                                
                                ctx.strokeStyle = gradient;
                                ctx.lineWidth = 3;
                                ctx.lineCap = 'round';
                                ctx.stroke();
                            }
                        }
                    });
                }
            });
            
            // –†–∏—Å—É–µ–º —É–∑–ª—ã
            treeNodes.forEach(node => {
                if (node.depth === 0) {
                    // –ö–æ—Ä–µ–Ω—å –¥–µ—Ä–µ–≤–∞ (—Å—Ç–∞—Ä—Ç–æ–≤—ã–π —É–∑–µ–ª) - –∫—Ä–∞—Å–Ω—ã–π
                    drawNode(node.x, node.y, node.label, '#e74c3c', 40, true, false);
                } else if (node.isLeaf) {
                    // –õ–∏—Å—Ç—å—è (–∫–æ–Ω–µ—á–Ω—ã–µ —É–∑–ª—ã) - –∑–µ–ª—ë–Ω—ã–µ
                    drawLeaf(node.x, node.y, node.label, node.pathNumber);
                } else {
                    // –ü—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ —É–∑–ª—ã - —Å–∏–Ω–∏–µ
                    drawNode(node.x, node.y, node.label, '#3498db', 32, false, false);
                }
            });
            
            // –ü–æ–¥—Å—á—ë—Ç –∫–æ–Ω–µ—á–Ω—ã—Ö —É–∑–ª–æ–≤ (–ø—É—Ç–µ–π)
            const pathsCount = treeNodes.filter(n => n.isLeaf).length;
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`‚úì –ù–∞–π–¥–µ–Ω–æ –ø—É—Ç–µ–π: ${pathsCount}`, canvas.width / 2, canvas.height - 20);
        }
        
        function drawNode(x, y, label, color, size, isRoot, isLeaf) {
            // –¢–µ–Ω—å
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 8;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
            
            // –ö—Ä—É–≥
            ctx.beginPath();
            ctx.arc(x, y, size / 2, 0, 2 * Math.PI);
            ctx.fillStyle = color;
            ctx.fill();
            
            // –°–±—Ä–æ—Å —Ç–µ–Ω–∏
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            // –û–±–≤–æ–¥–∫–∞
            let strokeColor = '#2d3436';
            let lineWidth = 3;
            if (isRoot) {
                strokeColor = '#c0392b';
                lineWidth = 4;
            } else if (isLeaf) {
                strokeColor = '#27ae60';
                lineWidth = 3;
            } else {
                strokeColor = '#2980b9';
            }
            
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = lineWidth;
            ctx.stroke();
            
            // –ë—É–∫–≤–∞
            ctx.fillStyle = 'white';
            ctx.font = `bold ${Math.max(16, size / 1.8)}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, x, y);
        }
        
        function drawLeaf(x, y, label, pathNumber) {
            // –¢–µ–Ω—å
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
            
            // –ö–æ–Ω–µ—á–Ω—ã–π —É–∑–µ–ª (–ª–∏—Å—Ç)
            ctx.beginPath();
            ctx.arc(x, y, 28, 0, 2 * Math.PI);
            
            // –ì—Ä–∞–¥–∏–µ–Ω—Ç –¥–ª—è –ª–∏—Å—Ç–∞
            const gradient = ctx.createRadialGradient(x - 8, y - 8, 5, x, y, 28);
            gradient.addColorStop(0, '#2ecc71');
            gradient.addColorStop(1, '#27ae60');
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // –°–±—Ä–æ—Å —Ç–µ–Ω–∏
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            // –û–±–≤–æ–¥–∫–∞
            ctx.strokeStyle = '#27ae60';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // –ë—É–∫–≤–∞
            ctx.fillStyle = 'white';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, x, y);
            
            // –ù–æ–º–µ—Ä –ø—É—Ç–∏ –ø–æ–¥ —É–∑–ª–æ–º
            if (pathNumber) {
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(pathNumber, x, y + 42);
            }
        }
        
        // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Å–ø–∏—Å–æ–∫ –ø—É—Ç–µ–π
        function displayPathsList() {
            const listDiv = document.getElementById('pathsList');
            const countDiv = document.getElementById('totalCount');
            const pathCountSpan = document.getElementById('pathCount');
            
            countDiv.textContent = paths.length;
            pathCountSpan.textContent = paths.length;
            
            listDiv.innerHTML = paths.map((path, i) => `
                <div class="path-item">
                    <strong>${i + 1}.</strong> ${path.join(' ‚Üí ')}
                </div>
            `).join('');
        }
        
        loadData();
        displayPathsList();
        resizeCanvas();
        
        // –ó–∞–ø—É—Å–∫ –∞–Ω–∏–º–∞—Ü–∏–∏
        function startAnimation() {
            if (isAnimating && !isPaused) return;
            
            if (!isPaused) {
                // –ù–∞—á–∏–Ω–∞–µ–º —Å–Ω–∞—á–∞–ª–∞
                currentLevel = 0;
                currentNodeIndexInLevel = 0;
                maxPathLength = Math.max(...paths.map(p => p.length));
                buildTree(); // –°—Ç—Ä–æ–∏–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–µ—Ä–µ–≤–∞
            }
            
            isAnimating = true;
            isPaused = false;
            
            document.getElementById('btnStart').disabled = true;
            document.getElementById('btnPause').disabled = false;
            
            animationInterval = setInterval(doAnimationStep, 800);
        }
        
        function pauseAnimation() {
            isPaused = true;
            isAnimating = false;
            clearInterval(animationInterval);
            
            document.getElementById('btnStart').disabled = false;
            document.getElementById('btnPause').disabled = true;
            document.getElementById('btnStart').textContent = '‚ñ∂Ô∏è –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å';
        }
        
        function resetAnimation() {
            isPaused = false;
            isAnimating = false;
            clearInterval(animationInterval);
            
            currentLevel = 0;
            currentNodeIndexInLevel = 0;
            
            document.getElementById('btnStart').disabled = false;
            document.getElementById('btnPause').disabled = true;
            document.getElementById('btnStart').textContent = '‚ñ∂Ô∏è –ó–∞–ø—É—Å—Ç–∏—Ç—å –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ';
            
            // –ü–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º –ø—É—Å—Ç–æ–µ –¥–µ—Ä–µ–≤–æ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawSourceImageWithHighlight(null);
        }
        
        function doAnimationStep() {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å –ª–∏ –≤—Å–µ —É—Ä–æ–≤–Ω–∏
            if (currentLevel >= maxPathLength) {
                pauseAnimation();
                document.getElementById('btnStart').textContent = '‚úÖ –ì–æ—Ç–æ–≤–æ';
                // –†–∏—Å—É–µ–º —Ñ–∏–Ω–∞–ª—å–Ω–æ–µ –¥–µ—Ä–µ–≤–æ
                draw();
                return;
            }
            
            // –ù–∞—Ö–æ–¥–∏–º —É–∑–ª—ã –Ω–∞ —Ç–µ–∫—É—â–µ–º —É—Ä–æ–≤–Ω–µ –≤–æ –≤—Å–µ—Ö –ø—É—Ç—è—Ö
            const nodesAtLevel = [];
            paths.forEach((path, pathIndex) => {
                if (currentLevel < path.length) {
                    nodesAtLevel.push({
                        node: path[currentLevel],
                        pathIndex: pathIndex
                    });
                }
            });
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –µ—â—ë —É–∑–ª—ã –Ω–∞ —ç—Ç–æ–º —É—Ä–æ–≤–Ω–µ
            if (currentNodeIndexInLevel >= nodesAtLevel.length) {
                // –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —É—Ä–æ–≤–Ω—é
                currentLevel++;
                currentNodeIndexInLevel = 0;
                return;
            }
            
            // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º —Ç–µ–∫—É—â–∏–π —É–∑–µ–ª —ç—Ç–æ–≥–æ —É—Ä–æ–≤–Ω—è
            if (nodesAtLevel.length > 0 && currentNodeIndexInLevel < nodesAtLevel.length) {
                drawSourceImageWithHighlight(nodesAtLevel[currentNodeIndexInLevel].node);
            }
            
            // –†–∏—Å—É–µ–º –¥–µ—Ä–µ–≤–æ —Å —Ç–µ–∫—É—â–∏–º —É—Ä–æ–≤–Ω–µ–º –∏ —É–∑–ª–æ–º
            drawTreeAnimatedByLevelAndNode(currentLevel, currentNodeIndexInLevel);
            
            // –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —É–∑–ª—É –Ω–∞ —ç—Ç–æ–º —É—Ä–æ–≤–Ω–µ
            currentNodeIndexInLevel++;
        }
        
        // –†–∏—Å—É–µ–º –∏—Å—Ö–æ–¥–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å –ø–æ–¥—Å–≤–µ—Ç–∫–æ–π —Ç–µ–∫—É—â–µ–≥–æ —É–∑–ª–∞
        function drawSourceImageWithHighlight(highlightNode) {
            const wrapper = document.getElementById('sourceImageWrapper');
            if (!sourceImage) return;
            
            // –°–æ–∑–¥–∞—ë–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π canvas –¥–ª—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = sourceImage.width;
            tempCanvas.height = sourceImage.height;
            
            // –†–∏—Å—É–µ–º –∏—Å—Ö–æ–¥–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
            tempCtx.drawImage(sourceImage, 0, 0);
            
            // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º —Ç–µ–∫—É—â–∏–π —É–∑–µ–ª
            if (highlightNode) {
                // –ù–∞—Ö–æ–¥–∏–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —É–∑–ª–∞ –∏–∑ –¥–∞–Ω–Ω—ã—Ö
                const savedData = localStorage.getItem('treeGraphData');
                if (savedData) {
                    const data = JSON.parse(savedData);
                    const nodeData = data.graph.nodes.find(n => n.label === highlightNode);
                    if (nodeData) {
                        // –†–∏—Å—É–µ–º —è—Ä–∫–∏–π –∫—Ä—É–≥ –≤–æ–∫—Ä—É–≥ —É–∑–ª–∞
                        tempCtx.beginPath();
                        tempCtx.arc(nodeData.x, nodeData.y, 25, 0, 2 * Math.PI);
                        tempCtx.strokeStyle = '#ff6b6b';
                        tempCtx.lineWidth = 5;
                        tempCtx.stroke();
                        
                        // –ê–Ω–∏–º–∞—Ü–∏–æ–Ω–Ω–æ–µ –∫–æ–ª—å—Ü–æ
                        tempCtx.beginPath();
                        tempCtx.arc(nodeData.x, nodeData.y, 35, 0, 2 * Math.PI);
                        tempCtx.strokeStyle = 'rgba(255, 107, 107, 0.3)';
                        tempCtx.lineWidth = 3;
                        tempCtx.stroke();
                    }
                }
            }
            
            // –ó–∞–º–µ–Ω—è–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
            wrapper.innerHTML = '';
            const img = new Image();
            img.src = tempCanvas.toDataURL();
            wrapper.appendChild(img);
        }
        
        // –†–∏—Å—É–µ–º –¥–µ—Ä–µ–≤–æ —Å –∞–Ω–∏–º–∞—Ü–∏–µ–π –ø–æ —É—Ä–æ–≤–Ω—è–º –∏ —É–∑–ª–∞–º
        function drawTreeAnimatedByLevelAndNode(maxLevel, nodeIndexInLevel) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // –°–æ–∑–¥–∞—ë–º –∫–∞—Ä—Ç—É —É–∑–ª–æ–≤
            const nodeMap = {};
            treeNodes.forEach(node => {
                nodeMap[node.key] = node;
            });
            
            // –†–∏—Å—É–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ —É–∑–ª—ã –∏ —Ä—ë–±—Ä–∞ –¥–æ —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ —É—Ä–æ–≤–Ω—è –≤–∫–ª—é—á–∏—Ç–µ–ª—å–Ω–æ
            const drawnEdges = new Set();
            
            // –†–∏—Å—É–µ–º —Ä—ë–±—Ä–∞ –¥–ª—è –≤—Å–µ—Ö –ø—É—Ç–µ–π –¥–æ maxLevel
            for (let pi = 0; pi < paths.length; pi++) {
                const path = paths[pi];
                const maxNode = Math.min(maxLevel, path.length - 1);
                
                for (let ni = 0; ni < maxNode; ni++) {
                    let currentKey = '';
                    for (let k = 0; k <= ni; k++) {
                        currentKey = currentKey ? `${currentKey}->${path[k]}` : path[k];
                    }
                    const node = nodeMap[currentKey];
                    
                    if (node && node.children && node.children.length > 0) {
                        node.children.forEach(childKey => {
                            const child = nodeMap[childKey];
                            if (child) {
                                const edgeKey = `${node.key}->${childKey}`;
                                if (!drawnEdges.has(edgeKey)) {
                                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –¥–æ–ª–∂–Ω–æ –ª–∏ —ç—Ç–æ —Ä–µ–±—Ä–æ –±—ã—Ç—å –≤–∏–¥–Ω–æ
                                    let nextKey = '';
                                    for (let k = 0; k <= ni + 1; k++) {
                                        nextKey = nextKey ? `${nextKey}->${path[k]}` : path[k];
                                    }
                                    if (nextKey === childKey) {
                                        drawnEdges.add(edgeKey);
                                        drawEdge(node, child);
                                    }
                                }
                            }
                        });
                    }
                }
            }
            
            // –†–∏—Å—É–µ–º —É–∑–ª—ã –¥–æ maxLevel –≤–∫–ª—é—á–∏—Ç–µ–ª—å–Ω–æ
            const drawnNodes = new Set(); // –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º —É–∂–µ –Ω–∞—Ä–∏—Å–æ–≤–∞–Ω–Ω—ã–µ —É–∑–ª—ã
            for (let pi = 0; pi < paths.length; pi++) {
                const path = paths[pi];
                const maxNode = Math.min(maxLevel + 1, path.length);
                
                for (let ni = 0; ni < maxNode; ni++) {
                    let currentKey = '';
                    for (let k = 0; k <= ni; k++) {
                        currentKey = currentKey ? `${currentKey}->${path[k]}` : path[k];
                    }
                    const node = nodeMap[currentKey];
                    if (node && !drawnNodes.has(currentKey)) {
                        // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ–∫—É—â–∏–π —É–∑–µ–ª –Ω–∞ —Ç–µ–∫—É—â–µ–º —É—Ä–æ–≤–Ω–µ
                        const isCurrent = (ni === maxLevel && pi === nodeIndexInLevel);
                        drawNodeAnimated(node, isCurrent);
                        drawnNodes.add(currentKey); // –û—Ç–º–µ—á–∞–µ–º —É–∑–µ–ª –∫–∞–∫ –Ω–∞—Ä–∏—Å–æ–≤–∞–Ω–Ω—ã–π
                    }
                }
            }
            
            // –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ç–µ–∫—É—â–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–∏
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            
            // –°—á–∏—Ç–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–∑–ª–æ–≤ –Ω–∞ —ç—Ç–æ–º —É—Ä–æ–≤–Ω–µ
            const nodesAtThisLevel = paths.filter(p => maxLevel < p.length).length;
            ctx.fillText(`–£—Ä–æ–≤–µ–Ω—å ${maxLevel} | –î–æ–±–∞–≤–ª—è–µ–º —É–∑–µ–ª ${nodeIndexInLevel + 1}/${nodesAtThisLevel}`, canvas.width / 2, canvas.height - 20);
        }
        
        function drawEdge(from, to) {
            const nodeRadius = from.depth === 0 ? 20 : 16;
            const childRadius = to.isLeaf ? 14 : 16;
            
            const angle = Math.atan2(to.y - from.y, to.x - from.x);
            const startX = from.x + nodeRadius * Math.cos(angle);
            const startY = from.y + nodeRadius * Math.sin(angle);
            const endX = to.x - childRadius * Math.cos(angle);
            const endY = to.y - childRadius * Math.sin(angle);
            
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            
            const gradient = ctx.createLinearGradient(startX, startY, endX, endY);
            gradient.addColorStop(0, '#95a5a6');
            gradient.addColorStop(1, '#7f8c8d');
            
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.stroke();
        }
        
        function drawNodeAnimated(node, isCurrent) {
            const size = node.depth === 0 ? 40 : (node.isLeaf ? 28 : 32);
            let color = '#3498db';
            
            if (node.depth === 0) {
                color = '#e74c3c';
            } else if (node.isLeaf) {
                color = '#2ecc71';
            }
            
            // –ê–Ω–∏–º–∞—Ü–∏—è —Ç–µ–∫—É—â–µ–≥–æ —É–∑–ª–∞
            if (isCurrent) {
                ctx.shadowColor = 'rgba(255, 107, 107, 0.5)';
                ctx.shadowBlur = 20;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            } else {
                ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
            }
            
            ctx.beginPath();
            ctx.arc(node.x, node.y, size / 2, 0, 2 * Math.PI);
            ctx.fillStyle = color;
            ctx.fill();
            
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            
            let strokeColor = node.depth === 0 ? '#c0392b' : (node.isLeaf ? '#27ae60' : '#2980b9');
            ctx.strokeStyle = isCurrent ? '#ff6b6b' : strokeColor;
            ctx.lineWidth = isCurrent ? 5 : 3;
            ctx.stroke();
            
            ctx.fillStyle = 'white';
            ctx.font = `bold ${Math.max(16, size / 1.8)}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node.label, node.x, node.y);
            
            if (node.isLeaf && node.pathNumber) {
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(node.pathNumber, node.x, node.y + 42);
            }
        }
    </script>
</body>
</html>
